#程序执行报告#
-----
###1.程序说明###

>使用请求分区分配方式对内存进行管理调度，内容如下：假设每个页面可存放10条指令，分配给一个作业的内存块为4。模拟一个作业的执行过程，该作业有320条指令，即它的地址空间为32页，目前所有页还没有调入内存。

###2.程序需求###

>1.在模拟过程中，如果所访问指令在内存中，则显示其物理地址，并转到下一条指令

>2.如果没有在内存中，则发生缺页，此时需要记录缺页次数，并将其调入内存。如果4个内存块中已装入作业，则需进行页面置换。

>3.所有320条指令执行完成后，计算并显示作业执行过程中发生的缺页率。
置换算法可以选用FIFO或者LRU算法，可以进行切换。

###3.指令###
>一半的指令顺序执行，1/4的指令在前半段指令内随机数跳转，1/4的指令在后半段指令内随机数跳转。准确而言，所有逻辑地址模4余0的指令在后半段跳转，模4余2的指令在前半段跳转，其余指令顺序执行。

###4.代码###

######1.变量######
>class instruction，指令类，包括本条指令的逻辑地址与下一条指令的逻辑地址

>page_tabel,页表，用来表示对应下标的页存储在哪个内存块中，实现逻辑地址到物理地址的转换，使用一个长度为32的list来储存。

>s，二维数组，代表程序段，用于存储指令

>FIFOlist，用于模拟栈，存储页进入内存的先后信息

>LRUlist，用于记录块内页的使用频率信息

######2.实现方案######
>每0.1s进行一次更新（即读取下一条指令），然后根据下一条指令的逻辑地址查看页表判断下一条指令所在页是否在内存中，若存在则根据物理地址访问下一条指令，否则根据页面置换算法调页，然后将下一条指令作为当前指令并对下一条指令进行更新，0.1s后继续下一次执行指令，重复以上操作320次。

######3.核心控制函数######
>def if\_in\_layer() 判断当前指令所在页是否在内存中的函数
>
>def insnum2insposition(insnum) 将逻辑地址转为在全部指令中的具体位置，进而转化为实际物理地址
>
>def FIFO(newpage) 当内存块中没有下一条指令所在页面时，根据FIFO算法进行页面置换
>
>def LRU(newpage) 当内存块中没有下一条指令所在页面时，根据LRU算法进行页面置换
>
>def LRUupdate(newpage) 对LRUlist进行更新
>
>def update() 指令执行函数（更新函数），每0.1s执行一次

###4.界面###

![image 初始界面](https://github.com/pdzsbl/ima/blob/master/sd.png)

![image 运行界面](https://github.com/pdzsbl/ima/blob/master/JSN1_7A3BE6NRHE6%40RQ4%5DTS.png)

###5.缺页率###
经过实验，发现FIFO算法和LRU的缺页率稳定在55%~65%左右，二者缺页率相近。

###6.平台###
python3.6 + wxpython

